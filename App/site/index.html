<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Streaming Service</title>
    <link rel="icon" type="image/x-icon" href="icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .dashboard-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .storage-info {
            margin-bottom: 20px;
        }

        .storage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .storage-header h2 {
            color: #667eea;
            font-size: 1.5em;
        }

        .storage-text {
            font-size: 1.1em;
            color: #666;
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        .videos-section h2 {
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .video-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .video-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
            border-color: #667eea;
        }

        .video-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 12px;
            word-break: break-word;
        }

        .video-details {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .video-detail-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #666;
        }

        .detail-label {
            font-weight: 600;
            color: #667eea;
        }

        .detail-value {
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
        }

        .refresh-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: 600;
        }

        .refresh-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .refresh-btn:active {
            transform: scale(0.98);
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .compile-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: 600;
        }

        .compile-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .compile-btn:active {
            transform: scale(0.98);
        }

        .compile-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .qr-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-weight: 600;
        }

        .qr-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .qr-btn:active {
            transform: scale(0.98);
        }

        .qr-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .qr-modal.show {
            display: flex;
        }

        .qr-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
        }

        .qr-content h3 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .qr-content canvas {
            margin: 20px auto;
            display: block;
        }

        .qr-content p {
            color: #666;
            margin: 10px 0;
            word-break: break-all;
        }

        .close-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
        }

        .close-btn:hover {
            background: #5568d3;
        }

        .settings-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #f0f0f0;
        }

        .settings-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .directory-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .directory-input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9em;
            font-family: monospace;
        }

        .directory-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .browse-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
        }

        .browse-btn:hover {
            background: #5568d3;
        }

        .save-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
        }

        .save-btn:hover {
            transform: scale(1.05);
        }

        .current-directory {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
            font-family: monospace;
            word-break: break-all;
        }

        .status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Movie Streaming Service</h1>
            <p>Dashboard</p>
        </div>

        <div class="dashboard-card">
            <div class="storage-info">
                <div class="storage-header">
                    <h2>üíæ Storage available</h2>
                    <div class="action-buttons">
                        <button class="compile-btn" onclick="compileRokuApp()" id="compileBtn">üì∫ Compile Roku App</button>
                        <button class="qr-btn" onclick="showWebsiteQR()">üì± Website QR</button>
                        <button class="qr-btn" onclick="showAppQR()">üì¶ Download App QR</button>
                        <button class="refresh-btn" onclick="loadData()">üîÑ Refresh</button>
                    </div>
                </div>
                <div class="storage-text" id="storageText">Loading...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                </div>
                <div class="status-message" id="statusMessage"></div>

                <div class="settings-section">
                    <h3>‚öôÔ∏è Choose Movie Folder</h3>
                    <div class="directory-input-group">
                        <input type="text" id="videoDirectoryInput" class="directory-input" placeholder="/path/to/videos">
                        <button class="browse-btn" onclick="browseDirectory()">üìÅ Browse</button>
                        <button class="save-btn" onclick="saveVideoDirectory()">üíæ Save</button>
                    </div>
                    <div class="current-directory" id="currentDirectory">Current: Loading...</div>
                </div>
            </div>
        </div>

        <div class="dashboard-card">
            <div class="videos-section">
                <h2>üìπ Video Library</h2>
                <div id="videoList" class="video-grid">
                    <div class="loading">Loading videos...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div class="qr-modal" id="qrModal">
        <div class="qr-content">
            <h3 id="qrTitle">QR Code</h3>
            <canvas id="qrCanvas"></canvas>
            <p id="qrUrl"></p>
            <button class="close-btn" onclick="closeQRModal()">Close</button>
        </div>
    </div>

    <script>
        const { execSync } = require('child_process');
        const os = require('os');

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function getSystemDiskUsage() {
            try {
                const platform = os.platform();
                let totalSpace = 0;
                let usedSpace = 0;

                if (platform === 'darwin' || platform === 'linux') {
                    // macOS or Linux - use df command
                    const output = execSync('df -k', { encoding: 'utf-8' });
                    const lines = output.split('\n');

                    // Skip header line
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const parts = line.split(/\s+/);
                        // Only count main filesystem mounts (skip devfs, tmpfs, etc.)
                        if (parts[0].startsWith('/dev/disk') || parts[0].startsWith('/dev/sd') || parts[0].startsWith('/dev/hd')) {
                            const size = parseInt(parts[1]) * 1024; // Convert KB to bytes
                            const used = parseInt(parts[2]) * 1024;

                            if (!isNaN(size) && !isNaN(used)) {
                                totalSpace += size;
                                usedSpace += used;
                            }
                        }
                    }
                } else if (platform === 'win32') {
                    // Windows - use wmic command
                    const output = execSync('wmic logicaldisk get size,freespace', { encoding: 'utf-8' });
                    const lines = output.split('\n');

                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const parts = line.split(/\s+/);
                        if (parts.length >= 2) {
                            const freeSpace = parseInt(parts[0]);
                            const size = parseInt(parts[1]);

                            if (!isNaN(size) && !isNaN(freeSpace) && size > 0) {
                                totalSpace += size;
                                usedSpace += (size - freeSpace);
                            }
                        }
                    }
                }

                return { total: totalSpace, used: usedSpace };
            } catch (error) {
                console.error('Error getting disk usage:', error);
                return { total: 0, used: 0 };
            }
        }

        async function loadVideoDirectory() {
            try {
                const response = await fetch('http://localhost:3000/config');
                const config = await response.json();

                const directoryInput = document.getElementById('videoDirectoryInput');
                const currentDirectory = document.getElementById('currentDirectory');

                directoryInput.value = config.videoDirectory;
                currentDirectory.textContent = `Current: ${config.videoDirectory}`;
            } catch (error) {
                console.error('Error loading video directory:', error);
            }
        }

        async function browseDirectory() {
            // Check if we have the selectDirectory function (from preload)
            if (typeof window.selectDirectory === 'function') {
                try {
                    const selectedPath = await window.selectDirectory();
                    if (selectedPath) {
                        document.getElementById('videoDirectoryInput').value = selectedPath;
                    }
                } catch (error) {
                    console.error('Error selecting directory:', error);
                    alert('Error selecting directory: ' + error.message);
                }
            } else {
                // Fallback to prompt if IPC is not available
                const directoryPath = prompt('Enter the full path to your videos directory:');
                if (directoryPath) {
                    document.getElementById('videoDirectoryInput').value = directoryPath;
                }
            }
        }

        async function saveVideoDirectory() {
            const directoryInput = document.getElementById('videoDirectoryInput');
            const statusMessage = document.getElementById('statusMessage');
            const newDirectory = directoryInput.value.trim();

            if (!newDirectory) {
                statusMessage.className = 'status-message error';
                statusMessage.style.display = 'block';
                statusMessage.textContent = '‚ùå Please enter a directory path';
                setTimeout(() => { statusMessage.style.display = 'none'; }, 3000);
                return;
            }

            try {
                const response = await fetch('http://localhost:3000/update-video-directory', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ directory: newDirectory })
                });

                const data = await response.json();

                if (response.ok) {
                    statusMessage.className = 'status-message success';
                    statusMessage.style.display = 'block';
                    statusMessage.textContent = `‚úÖ Video directory updated to: ${data.directory}`;

                    document.getElementById('currentDirectory').textContent = `Current: ${data.directory}`;

                    // Reload video list
                    setTimeout(() => {
                        loadData();
                        statusMessage.style.display = 'none';
                    }, 2000);
                } else {
                    statusMessage.className = 'status-message error';
                    statusMessage.style.display = 'block';
                    statusMessage.textContent = `‚ùå Error: ${data.error}`;
                    setTimeout(() => { statusMessage.style.display = 'none'; }, 5000);
                }
            } catch (error) {
                console.error('Error updating directory:', error);
                statusMessage.className = 'status-message error';
                statusMessage.style.display = 'block';
                statusMessage.textContent = `‚ùå Error: ${error.message}`;
                setTimeout(() => { statusMessage.style.display = 'none'; }, 5000);
            }
        }

        async function loadData() {
            const videoList = document.getElementById('videoList');
            const storageText = document.getElementById('storageText');
            const progressFill = document.getElementById('progressFill');

            try {
                // Get system disk usage
                const diskUsage = getSystemDiskUsage();

                if (diskUsage.total > 0) {
                    const usedGB = (diskUsage.used / (1024 * 1024 * 1024)).toFixed(2);
                    const totalGB = (diskUsage.total / (1024 * 1024 * 1024)).toFixed(2);
                    const percentage = ((diskUsage.used / diskUsage.total) * 100).toFixed(1);

                    storageText.textContent = `${usedGB} GB / ${totalGB} GB used`;
                    progressFill.style.width = `${Math.min(percentage, 100)}%`;
                    progressFill.textContent = `${percentage}%`;

                    // Update color based on usage
                    if (percentage > 90) {
                        progressFill.style.background = 'linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%)';
                    } else if (percentage > 75) {
                        progressFill.style.background = 'linear-gradient(90deg, #ffa500 0%, #ff8c00 100%)';
                    } else {
                        progressFill.style.background = 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)';
                    }
                } else {
                    storageText.textContent = 'Unable to get disk usage';
                }

                // Load video data
                videoList.innerHTML = '<div class="loading">Loading videos...</div>';

                const response = await fetch('http://localhost:3000/json');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Display videos
                if (!data || data.length === 0) {
                    videoList.innerHTML = '<div class="loading">No videos found</div>';
                    return;
                }

                videoList.innerHTML = '';
                data.forEach(video => {
                    const card = document.createElement('div');
                    card.className = 'video-card';

                    const title = document.createElement('div');
                    title.className = 'video-title';
                    title.textContent = video.name || video.title || 'Untitled';

                    const details = document.createElement('div');
                    details.className = 'video-details';

                    // Add video details
                    const detailFields = [
                        { label: 'Size', value: video.size ? formatBytes(video.size) : 'N/A' },
                        { label: 'Duration', value: video.duration || 'N/A' },
                        { label: 'Format', value: video.format || video.extension || 'N/A' },
                        { label: 'Path', value: video.path || 'N/A' }
                    ];

                    detailFields.forEach(field => {
                        const item = document.createElement('div');
                        item.className = 'video-detail-item';
                        item.innerHTML = `
                            <span class="detail-label">${field.label}:</span>
                            <span class="detail-value">${field.value}</span>
                        `;
                        details.appendChild(item);
                    });

                    card.appendChild(title);
                    card.appendChild(details);
                    videoList.appendChild(card);
                });

            } catch (error) {
                console.error('Error loading data:', error);
                videoList.innerHTML = `<div class="error">Error loading videos: ${error.message}<br>Make sure the server is running on localhost:3000</div>`;
                storageText.textContent = 'Unable to load storage data';
            }
        }

        // Compile Roku App function
        function compileRokuApp() {
            const { exec } = require('child_process');
            const path = require('path');
            const fs = require('fs');

            const compileBtn = document.getElementById('compileBtn');
            const statusMessage = document.getElementById('statusMessage');

            // Disable button and show status
            compileBtn.disabled = true;
            compileBtn.textContent = '‚è≥ Compiling...';
            statusMessage.className = 'status-message info';
            statusMessage.style.display = 'block';
            statusMessage.textContent = 'Starting Roku app compilation...';

            // Determine the correct paths based on whether app is packaged
            let projectRoot;

            // Check if we're in a packaged app by looking for process.resourcesPath
            if (process.resourcesPath && fs.existsSync(path.join(process.resourcesPath, 'app.asar.unpacked'))) {
                // In packaged app, use app.asar.unpacked directory
                projectRoot = path.join(process.resourcesPath, 'app.asar.unpacked');
                console.log('Running in packaged mode, projectRoot:', projectRoot);
            } else {
                // In development, go up from App/site
                projectRoot = path.join(__dirname, '..', '..');
                console.log('Running in development mode, projectRoot:', projectRoot);
            }

            const rokuAppDir = path.join(projectRoot, 'rokuapp');
            const configPath = path.join(projectRoot, 'config.json');
            const mainScenePath = path.join(rokuAppDir, 'components', 'MainScene.brs');
            const outputZip = path.join(rokuAppDir, 'MatthiasTV.zip');

            try {
                // Read config.json to get the current URL
                let serverURL = 'http://192.168.86.39'; // Default fallback
                if (fs.existsSync(configPath)) {
                    const configData = fs.readFileSync(configPath, 'utf8');
                    const config = JSON.parse(configData);
                    if (config.url) {
                        serverURL = config.url;
                    }
                }

                statusMessage.textContent = `Updating MainScene.brs with URL: ${serverURL}...`;

                // Read MainScene.brs file
                let mainSceneContent = fs.readFileSync(mainScenePath, 'utf8');

                // Update line 3 with the new URL
                const lines = mainSceneContent.split('\n');
                lines[2] = `    URL = "${serverURL}"`;
                mainSceneContent = lines.join('\n');

                // Write back to file
                fs.writeFileSync(mainScenePath, mainSceneContent, 'utf8');

                statusMessage.textContent = 'Creating zip file...';

                // Remove old zip if it exists
                if (fs.existsSync(outputZip)) {
                    fs.unlinkSync(outputZip);
                }

                // Create zip file from rokuapp directory contents
                const command = `cd "${rokuAppDir}" && zip -r MatthiasTV.zip components images source manifest -x "*.DS_Store" -x "MatthiasTV.zip"`;

                exec(command, (error, stdout, stderr) => {
                    if (error) {
                        console.error('Compilation error:', error);
                        statusMessage.className = 'status-message error';
                        statusMessage.textContent = `‚ùå Compilation failed: ${error.message}`;
                        compileBtn.disabled = false;
                        compileBtn.textContent = 'üì∫ Compile Roku App';
                        return;
                    }

                    if (stderr) {
                        console.error('stderr:', stderr);
                    }

                    console.log('stdout:', stdout);

                    // Check if zip was created successfully
                    if (fs.existsSync(outputZip)) {
                        const stats = fs.statSync(outputZip);
                        const fileSizeInBytes = stats.size;
                        const fileSizeInKB = (fileSizeInBytes / 1024).toFixed(2);

                        statusMessage.className = 'status-message success';
                        statusMessage.textContent = `‚úÖ Roku app compiled successfully with URL ${serverURL}! (${fileSizeInKB} KB) - File saved at: ${outputZip}`;
                    } else {
                        statusMessage.className = 'status-message error';
                        statusMessage.textContent = '‚ùå Compilation completed but zip file not found.';
                    }

                    compileBtn.disabled = false;
                    compileBtn.textContent = 'üì∫ Compile Roku App';
                });

            } catch (error) {
                console.error('Error during compilation:', error);
                statusMessage.className = 'status-message error';
                statusMessage.textContent = `‚ùå Error: ${error.message}`;
                compileBtn.disabled = false;
                compileBtn.textContent = 'üì∫ Compile Roku App';
            }
        }

        // QR Code functions
        const QRCode = require('qrcode');

        function closeQRModal() {
            document.getElementById('qrModal').classList.remove('show');
        }

        function showQRCode(title, url) {
            const modal = document.getElementById('qrModal');
            const canvas = document.getElementById('qrCanvas');
            const titleEl = document.getElementById('qrTitle');
            const urlEl = document.getElementById('qrUrl');

            titleEl.textContent = title;
            urlEl.textContent = url;

            QRCode.toCanvas(canvas, url, {
                width: 300,
                margin: 2,
                color: {
                    dark: '#667eea',
                    light: '#ffffff'
                }
            }, (error) => {
                if (error) {
                    console.error('QR Code error:', error);
                    alert('Failed to generate QR code: ' + error.message);
                    return;
                }
                modal.classList.add('show');
            });
        }

        function showWebsiteQR() {
            const path = require('path');
            const fs = require('fs');

            // Get the URL from config
            let projectRoot;
            if (process.resourcesPath && fs.existsSync(path.join(process.resourcesPath, 'app.asar.unpacked'))) {
                projectRoot = path.join(process.resourcesPath, 'app.asar.unpacked');
            } else {
                projectRoot = path.join(__dirname, '..', '..');
            }

            const configPath = path.join(projectRoot, 'config.json');
            let serverURL = 'http://192.168.86.39:3000';

            if (fs.existsSync(configPath)) {
                const configData = fs.readFileSync(configPath, 'utf8');
                const config = JSON.parse(configData);
                if (config.url) {
                    serverURL = config.url;
                }
            }

            showQRCode('üì± Scan to Visit Website', serverURL);
        }

        function showAppQR() {
            const path = require('path');
            const fs = require('fs');
            const statusMessage = document.getElementById('statusMessage');

            // Get paths
            let projectRoot;
            if (process.resourcesPath && fs.existsSync(path.join(process.resourcesPath, 'app.asar.unpacked'))) {
                projectRoot = path.join(process.resourcesPath, 'app.asar.unpacked');
            } else {
                projectRoot = path.join(__dirname, '..', '..');
            }

            const rokuAppDir = path.join(projectRoot, 'rokuapp');
            const sourceZip = path.join(rokuAppDir, 'MatthiasTV.zip');
            const siteDir = path.join(projectRoot, 'site');
            const destZip = path.join(siteDir, 'MatthiasTV.zip');
            const configPath = path.join(projectRoot, 'config.json');

            // Check if the Roku app has been compiled
            if (!fs.existsSync(sourceZip)) {
                statusMessage.className = 'status-message error';
                statusMessage.style.display = 'block';
                statusMessage.textContent = '‚ùå Please compile the Roku app first!';
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 3000);
                return;
            }

            try {
                // Copy the zip file to the site directory
                fs.copyFileSync(sourceZip, destZip);

                // Get server URL
                let serverURL = 'http://192.168.86.39:3000';
                if (fs.existsSync(configPath)) {
                    const configData = fs.readFileSync(configPath, 'utf8');
                    const config = JSON.parse(configData);
                    if (config.url) {
                        serverURL = config.url;
                    }
                }

                const downloadURL = `${serverURL}/MatthiasTV.zip`;
                showQRCode('üì¶ Scan to Download Roku App', downloadURL);

                statusMessage.className = 'status-message success';
                statusMessage.style.display = 'block';
                statusMessage.textContent = `‚úÖ Roku app is now available at: ${downloadURL}`;
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);

            } catch (error) {
                console.error('Error copying zip file:', error);
                statusMessage.className = 'status-message error';
                statusMessage.style.display = 'block';
                statusMessage.textContent = `‚ùå Error: ${error.message}`;
            }
        }

        // Load data on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadData();
            loadVideoDirectory();
        });

        // Auto-refresh every 30 seconds
        setInterval(loadData, 30000);
    </script>
</body>
</html>
